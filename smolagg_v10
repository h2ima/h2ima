#pragma rtGlobals=1		// Use modern global access method.

Function SmolKinetic(pw, tt, yw, dydt)

	wave pw
	variable tt
	wave yw
	wave dydt
	
	wave waveaij
	variable i, j, k
	variable sumyw
	variable sumij
	variable pnts; pnts = pw[0]
	
	dydt[0] = 0
	sumyw = 0

	i =1
	do
	sumyw += waveaij[1][i]*yw[i]
	i += 1
	while (i < pnts)
	dydt[1] = (-2*yw[1]*sumyw)
	
	sumij = 0
	k = 2
	do
	sumyw = 0
	i = 1
		do
		sumyw += waveaij[k][i]*yw[i]
		i += 1
		while (i < pnts)
		
		sumij = 0
		j = 1
		do
		sumij += waveaij[k-j][j]*yw[j]*yw[k-j]
		j += 1
		while (j < k)
	dydt[k] = sumij - 2*yw[k]*sumyw
	k += 1
	while (k < pnts)
	
	return 0
	
End


Function calc_kernel_original(pnts, df) // Smoluchowski original kernel

	variable pnts
	variable df
	variable b; b = 1/df
	make/o/d/n=(pnts, pnts) waveaij; waveaij = 0
	variable i, j

	i = 1
	do
		j = 1
		do
		waveaij[i][j] = 0.25*((i^b)+(j^b))*((i^(-b))+(j^(-b)))
		j += 1
		while (j < pnts)
		i += 1
	while (i < pnts)

End


Function calc_kernel_cylinder(pnts, deltaomega, Lm, d) // kernel for cylinder // end-to-end aggrgation mechanism // Owczarz et al., Langmuir (2015)

	variable pnts
	variable deltaomega, Lm, d
	variable lambda; lambda = Lm/d
	variable coef; coef = deltaomega/d
	variable vi, vj
	variable mi, mj
	make/o/d/n=(pnts, pnts) waveaij; waveaij = 0
	variable i, j

	i = 1
	do
		j = 1
		do
		vi = 0.312 + 0.565*(i*lambda)^(-1) - 0.1*(i*lambda)^(-2)
		vj = 0.312 + 0.565*(j*lambda)^(-1) - 0.1*(j*lambda)^(-2)
		
		mi = (ln(i*lambda)+vi)/(i*lambda)
		mj = (ln(j*lambda)+vj)/(j*lambda)
		
		waveaij[i][j] = (coef^2)/((i+j)*lambda) * (mi+mj)
		
		j += 1
		while (j < pnts)
		i += 1
	while (i < pnts)

End


Function calc_kernel_multi(pnts, df, deltaomega, Lm, d, kernel)

	variable pnts
	variable df
	variable deltaomega, Lm, d
	variable kernel
	variable b; b = 1/df
	variable lambda; lambda = Lm/d
	variable coef; coef = deltaomega/d
	variable vi, vj
	variable mi, mj
	make/o/d/n=(pnts, pnts) waveaij; waveaij = 0
	variable i, j
	
	if (kernel == 0) // 100-mer以降は、100a-mer対100a-mer（a = 1, 2, 3, ...）のみ値を持つ（円柱カーネルで計算）
		i = 1
		do
			j = 1
			do
			waveaij[i][j] = 0.25*((i^b)+(j^b))*((i^(-b))+(j^(-b)))
			j += 1
			while (j < 100)
			i += 1
		while (i < 100)
	
		i = 100
		do
			j = 100
			do
			vi = 0.312 + 0.565*(i*lambda)^(-1) - 0.1*(i*lambda)^(-2)
			vj = 0.312 + 0.565*(j*lambda)^(-1) - 0.1*(j*lambda)^(-2)
		
			mi = (ln(i*lambda)+vi)/(i*lambda)
			mj = (ln(j*lambda)+vj)/(j*lambda)
		
			waveaij[i][j] = (coef^2)/((i+j)*lambda) * (mi+mj)
		
			j += 100
			while (j < pnts)
			i += 100
		while (i < pnts)

	elseif (kernel == 1) // 100-mer以降もすべて値を持つ（円柱カーネルで計算）
		i = 1
		do
			j = 1
			do
			waveaij[i][j] = 0.25*((i^b)+(j^b))*((i^(-b))+(j^(-b)))
			j += 1
			while (j < 100)
			i += 1
		while (i < 100)
	
		i = 1
		do
			j = 100
			do
			vi = 0.312 + 0.565*(i*lambda)^(-1) - 0.1*(i*lambda)^(-2)
			vj = 0.312 + 0.565*(j*lambda)^(-1) - 0.1*(j*lambda)^(-2)
		
			mi = (ln(i*lambda)+vi)/(i*lambda)
			mj = (ln(j*lambda)+vj)/(j*lambda)
		
			waveaij[i][j] = (coef^2)/((i+j)*lambda) * (mi+mj)
		
			j += 1
			while (j < pnts)
			i += 1
		while (i < 100)
	
		i = 100
		do
			j = 1
			do
			vi = 0.312 + 0.565*(i*lambda)^(-1) - 0.1*(i*lambda)^(-2)
			vj = 0.312 + 0.565*(j*lambda)^(-1) - 0.1*(j*lambda)^(-2)
		
			mi = (ln(i*lambda)+vi)/(i*lambda)
			mj = (ln(j*lambda)+vj)/(j*lambda)
		
			waveaij[i][j] = (coef^2)/((i+j)*lambda) * (mi+mj)
		
			j += 1
			while (j < pnts)
			i += 1
		while (i < pnts)
	
	endif
	
End


Function calc_mass(dif_pnts, time_pnts)

	variable dif_pnts, time_pnts
	wave SmolKin
	make/o/d/n=(time_pnts) wsumsm; wsumsm = 0
	variable sumsm
	variable i, j
	
	i = 0
	do
		j = 1
		sumsm = 0
		do
		sumsm += j*SmolKin[i][j]
		j += 1
		while (j < dif_pnts)
		wsumsm[i] = sumsm
		i += 1
	while (i < time_pnts)
	
End


Function calc_ii0(dif_pnts, time_pnts)

	variable dif_pnts, time_pnts
	wave SmolKin
	make/o/d/n=(time_pnts) w_ii0; w_ii0 = 0
	variable ii0
	variable i, j
	
	i = 0
	do
		j = 1
		ii0 = 0
		do
		ii0 += SmolKin[i][j]*j^2
		j += 1
		while (j < dif_pnts)
		w_ii0[i] = ii0
		i += 1
	while (i < time_pnts)

End


Macro Main_SmolRun_original() // calculation procedures for original Smoluchowski aggregation equations

	variable num_dif_eq = 801  // number of differential equations
	variable num_time_pnts = 101  // number of time points
	variable df = 2 // fractal dimension
	make/o/d/n=(num_time_pnts, num_dif_eq) SmolKin; SmolKin = 0
	setscale/p x 0, 1, "", SmolKin
	
	calc_kernel_original(num_dif_eq, df)
	make/o/d/n=1 param
	param[0] = num_dif_eq
	SmolKin[0][1]=1
	integrateode SmolKinetic param SmolKin

	make/o/d/n=(num_time_pnts) tau; tau = 0
	tau = 1*p
	
	calc_mass(num_dif_eq, num_time_pnts)
	calc_ii0(num_dif_eq, num_time_pnts)

End


Macro Main_SmolRun_cylinder() // calculation procedures for cylinder

	variable num_dif_eq = 301 // number of differential equations
	variable num_time_pnts = 301 // number of time points
	variable deltaomega = 10^-8 // m*rad // delta; minimum allowed distance // omega; angle between two colliding fibrils
	variable Lm = 3*10^-9 // m // length of monomer
	variable b = 3*10^-9 // m // diameter of fibril
	make/o/d/n=(num_time_pnts, num_dif_eq) SmolKin; SmolKin = 0
	setscale/p x 0, 1, "", SmolKin
	
	calc_kernel_cylinder(num_dif_eq, deltaomega, Lm, b)
	make/o/d/n=1 param
	param[0] = num_dif_eq
	SmolKin[0][1]=1
	integrateode SmolKinetic param SmolKin
	
	make/o/d/n=(num_time_pnts) tau; tau = 0
	tau = 1*p
	
	calc_mass(num_dif_eq, num_time_pnts)
	calc_ii0(num_dif_eq, num_time_pnts)

End


Macro Main_SmolRun_multi() // calculation procedure for for multi kernel

	variable num_dif_eq = 501 // number of differential equations
	variable num_time_pnts = 301 // number of time points
	variable df = 2 // fractal dimension
	variable deltaomega = 10^-8 // m*rad // delta; minimum allowed distance // omega; angle between two colliding fibrils
	variable Lm = 3*10^-9 // m // length of monomer
	variable d = 3*10^-9 // m // diameter of fibril
	variable kernel = 1
	
	make/o/d/n=(num_time_pnts, num_dif_eq) SmolKin; SmolKin = 0
	setscale/p x 0, 1, "", SmolKin
	
	calc_kernel_multi(num_dif_eq, df, deltaomega, Lm, d, kernel)
	make/o/d/n=1 param
	param[0] = num_dif_eq
	SmolKin[0][1]=1
	integrateode SmolKinetic param SmolKin
	
	make/o/d/n=(num_time_pnts) tau; tau = 0
	tau = 1*p
	
	calc_mass(num_dif_eq, num_time_pnts)
	calc_ii0(num_dif_eq, num_time_pnts)
	
End
